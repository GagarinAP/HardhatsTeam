<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<title></title>
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
	<link href='https://fonts.googleapis.com/css?family=Lobster|Open+Sans:400,300,700,300italic,600&subset=latin,cyrillic' rel='stylesheet' type='text/css'>
</head>
<body>
	<header>
		<div class="container">
			<div class="author-name">Э. Гамма</div>
			<div class="author-name">Р. Хелм</div>
			<div class="author-name">Р. Джонсон</div>
			<div class="author-name">Дж. Влиссидес</div>
		</div>
	</header>
	<main>
		<section class="promo-section">
		<div class="overlay"></div>
			<div class="container">
				<div class="titles-wrapper">
						<h1>Приемы объектно-ориентированного проектирования </h1>
						<h3>Паттерны проектирования</h3>
					<div>
						<h5>Глава 4. Структурные паттерны : Паттерн Flyweight</h5>
					</div>
				</div>
			</div>
		</section>
		
		<section class="patterns-section">
			<div class="container">
				<ul style="display: inline;">
					<li style="display: inline;"><a href="index.html">Главная</a></li>
					<li style="display: inline;"><a> &raquo; </a></li>
					<li style="display: inline;"><a href="flyweight.html"><b>Паттерн Flyweight</b></a></li>
				</ul>
			</div>

			<div class="container">
				<h2 class="title">Паттерн Flyweight</h2>
					<h3>Название и классификация паттерна</h3>
					<p>Приспособленец - паттерн, структурирующий объекты.</p>
					<h4><i>Назначение</i></h4>
					<p>Использует разделение для эффективной поддержки множества мелких
					объектов.</p>
					<h4>Мотивация</h4>
					<p>В некоторых приложениях использование объектов могло бы быть очень по-
					лезным, но прямолинейная реализация оказывается недопустимо расточительной.
					Например, в большинстве редакторов документов имеются средства форма-
					тирования и редактирования текстов, в той или иной степени модульные. Объект-
					но-ориентированные редакторы обычно применяют объекты для представления
					таких встроенных элементов, как таблицы и рисунки. Но они не используют
					объекты для представления каждого символа, несмотря на то что это увеличило
					бы гибкость на самых нижних уровнях приложения. Ведь тогда к рисованию и фор-
					матированию символов и встроенных элементов можно былб бы применить еди-
					нообразный подход. И для поддержки новых наборов символов не пришлось бы
					как-либо затрагивать остальные функции редактора. Да и общая структура прило-
					жения отражала бы физическую структуру документа. На следующей диаграмме
					показано, как редактор документов мог бы воспользоваться объектами для пред-
					ставления символов.</p>
					<p>У такого дизайна есть один недостаток - стоимость. Даже в документе скром-
					ных размеров было бы несколько сотен тысяч объектов-символов, а это привело
					бы к расходованию огромного объема памяти и неприемлемым затратам во время
					выполнения. Паттерн приспособленец показывает, как разделять очень мелкие
					объекты без недопустимо высоких издержек.</p>
					<img src="img/img-pattern/img1561.jpg" alt="" />
					<p>Приспособленец - это разделяемый объект, который можно использовать
					одновременно в нескольких контекстах. В каждом контексте он выглядит как не-
					зависимый объект, то есть неотличим от экземпляра, который не разделяется.
					Приспособленцы не могут делать предположений о контексте, в котором работают.
					Ключевая идея здесь - различие между внутренним и внешним состояниями.
					Внутреннее состояние хранится в самом приспособленце и состоит из информа-
					ции, не зависящей от его контекста. Именно поэтому он может разделяться. Внеш-
					нее состояние зависит от контекста и изменяется вместе с ним, поэтому не подле-
					жит разделению. Объекты-клиенты отвечают за передачу внешнего состояния
					приспособленцу, когда в этом возникает необходимость.</p>
					<p>Приспособленцы моделируют концепции или сущности, число которых
					слишком велико для представления объектами. Например, редактор документов
					мог бы создать по одному приспособленцу для каждой буквы алфавита. Каждый
					приспособленец хранит код символа, но координаты положения символа в доку-
					менте и стиль его начертания определяются алгоритмами размещения текста
					и командами форматирования, действующими в том месте, где символ появляет-
					ся. Код символа - это внутреннее состояние, а все остальное - внешнее.</p>
					<p>Логически для каждого вхождения данного символа в документ существует
					объект.</p>
					<img src="img/img-pattern/img1572.jpg" alt="" />
					<p>Физически, однако, есть лишь по одному объекту-приспособленцу для каждо-
					го символа, который появляется в различных контекстах в структуре документа. Каж-
					дое вхождение данного объекта-символа ссылается на один и тот же экземпляр в раз-
					деляемом пуле объектов-приспособленцев.</p>
					<img src="img/img-pattern/img1570.jpg" alt="" />
					<p>Ниже изображена структура класса для этих объектов. Glyph - это абстракт-
					ный класс для представления графических объектов (некоторые из них могут
					быть приспособленцами). Операции, которые могут зависеть от внешнего состоя-
					ния, передают его в качестве параметра. Например, операциям Draw (рисование)
					и Intersects (пересечение) должно быть известно, в каком контексте встреча-
					ется глиф, иначе они не смогут выполнить то, что от них требуется.</p>
					<img src="img/img-pattern/img1579.jpg" alt="" />
					<p>Приспособленец, представляющий букву «а», содержит только соответствую-
					щий ей код; ни положение, ни шрифт буквы ему хранить не надо. Клиенты пере-
					дают приспособленцу всю зависящую от контекста информацию, которая нужна,
					чтобы он мог изобразить себя. Например, глифу Row известно, где его потомки
					должны себя показать, чтобы это выглядело как горизонтальная строка. Поэтому
					вместе с запросом на рисование он может передавать каждому потомку координаты.
					Поскольку число различных объектов-символов гораздо меньше, чем число
					символов в документе, то и общее количество объектов существенно меньше, чем
					было бы при простой реализации. Документ, в котором все символы изображают-
					ся одним шрифтом и цветом, создаст порядка 100 объектов-символов (это при-
					мерно равно числу кодов в таблице ASCII) независимо от своего размера. А по-
					скольку в большинстве документов применяется не более десятка различных
					комбинаций шрифта и цвета, то на практике эта величина возрастет несуществен-
					но. Поэтому абстракция объекта становится применимой и к отдельным символам.</p>
					<h4>Применимость</h4>
					<p>Эффективность паттерна приспособленец во многом зависит от того, как
					и где он используется. Применяйте этот паттерн, когда выполнены все нижепере-
					численные условия:</p>
						<ul>
							<li>а в приложении используется большое число объектов;</li>
							<li>а из-за этого накладные расходы на хранение высоки;</li>
							<li>а большую часть состояния объектов можно вынести вовне;</li>
							<li>а многие группы объектов можно заменить относительно небольшим количе-
							ством разделяемых объектов, поскольку внешнее состояние вынесено;</li>
							<li>а приложение не зависит от идентичности объекта. Поскольку объекты-при-
							способленцы могут разделяться, то проверка на идентичность возвратит
							«истину» для концептуально различных объектов.</li>
						</ul>
					<h4>Структура</h4>
					<img src="img/img-pattern/img1586.jpg" alt="" />
					На следующей диаграмме показано, как приспособленцы разделяются.
					<img src="img/img-pattern/img1584.jpg" alt="" />
					<h4>Участники</h4>
						<ul>
							<li><p>a Flyweight (Glyph) - приспособленец:</p>
								<ul>
									<li>- объявляет интерфейс, с помощью которого приспособленцы могут полу-
									чать внешнее состояние или как-то воздействовать на него;</li>
								</ul>
							</li>
							<li><p>a ConcreteFlyweight (Character) - конкретный приспособленец:</p>
								<ul>
									<li>- реализует интерфейс класса Flyweight и добавляет при необходимости
									внутреннее состояние. Объект класса ConcreteFlyweight должен быть
									разделяемым. Любое сохраняемое им состояние должно быть внутрен-
									ним, то есть не зависящим от контекста;</li>
								</ul>
							</li>
							<li><p>a UnsharedConcreteFlyweight (Row, Column) - неразделяемый конкретный
							приспособленец:</p>
								<ul>
									<li>- не все подклассы Flyweight обязательно должны быть разделяемыми.
									Интерфейс Flyweight допускает разделение, но не навязывает его. Часто
									у объектов UnsharedConcreteFlyweight на некотором уровне структуры
									приспособленца есть потомки в виде объектов класса Concret eFlyweight,
									как, например, у объектов классов Row и Column;</li>
								</ul>
							</li>
							<li><p>a FlyweightFactory - фабрика приспособленцев:</p>
								<ul>
									<li>- создает объекты-приспособленцы и управляет ими;</li>
									<li>- обеспечивает должное разделение приспособленцев. Когда клиент запра-
									шивает приспособленца, объект FlyweightFactory предоставляет су-
									ществующий экземпляр или создает новый, если готового еще нет;
									</li>
								</ul>
							</li>
							<li><p>a Client - клиент:</p>
								<ul>
									<li>- хранит ссылки на одного или нескольких приспособленцев;</li>
									<li>- вычисляет или хранит внешнее состояние приспособленцев.</li>
								</ul>
							</li>
						</ul>
					<h4>Отношения</h4>
						<ul>
							<li>а состояние, необходимое приспособленцу для нормальной работы, можно
							охарактеризовать как внутреннее или внешнее. Первое хранится в самом
							объекте ConcreteFlyweight. Внешнее состояние хранится или вычисля-
							ется клиентами. Клиент передает его приспособленцу при вызове операций;</li>
							<li>а клиенты не должны создавать экземпляры класса ConcreteFlyweight
							напрямую, а могут получать их только от объекта FlyweightFactory. Это
							позволит гарантировать корректное разделение.</li>
						</ul>
					<h4>Результаты</h4>
					<p>При использовании приспособленцев не исключены затраты на передачу, по-
					иск или вычисление внутреннего состояния, особенно если раньше оно хранилось
					как внутреннее. Однако такие расходы с лихвой компенсируются экономией па-
					мяти за счет разделения объектов-приспособленцев.</p>
					<p>Экономия памяти возникает по ряду причин:</p>
						<ul>
							<li>а уменьшение общего числа экземпляров;</li>
							<li>а сокращение объема памяти, необходимого для хранения внутреннего состо-
							яния;</li>
							<li>а вычисление, а не хранение внешнего состояния (если это действительно так).</li>
						</ul>
					<p>Чем выше степень разделения приспособленцев, тем существеннее экономия.
					С увеличением объема разделяемого состояния экономия также возрастает. Са-
					мого большого эффекта удается добиться, когда суммарный объем внутренней
					и внешней информации о состоянии велик, а внешнее состояние вычисляется, а не
					хранится. Тогда разделение уменьшает стоимость хранения внутреннего состояния,
					а за счет вычислений сокращается память, отводимая под внешнее состояние.</p>
					<p>Паттерн приспособленец часто применяется вместе с компоновщиком для
					представления иерархической структуры в виде графа с разделяемыми листовыми
					узлами. Из-за разделения указатель на родителя не может храниться в листовом
					узле-приспособленце, а должен передаваться ему как часть внешнего состояния.
					Это оказывает заметное влияние на способ взаимодействия объектов иерархии
					между собой.</p>
					<h4>Реализация</h4>
					<p>При реализации приспособленца следует обратить внимание на следующие
					вопросы:</p>
						<ul>
							<li>а вынесение внешнего состояния. Применимость паттерна в значительной сте-
							пени зависит от того, насколько легко идентифицировать внешнее состоя-
							ние и вынести его за пределы разделяемых объектов. Вынесение внешнего
							состояния не уменьшает стоимости хранения, если различных внешних со-
							стояний так же много, как и объектов до разделения. Лучший вариант -
							внешнее состояние вычисляется по объектам с другой структурой, требую-
							щей значительно меньшей памяти.
							Например, в нашем редакторе документов мы можем поместить карту с ти-
							пографской информацией в отдельную структуру, а не хранить шрифт и на-
							чертание вместе с каждым символом. Данная карта будет отслеживать не-
							прерывные серии символов с одинаковыми типографскими атрибутами.
							Когда объект-символ изображает себя, он получает типографские атрибуты
							от алгоритма обхода. Поскольку обычно в документах используется немно-
							го разных шрифтов и начертаний, то хранить эту информацию отдельно от
							объекта-символа гораздо эффективнее, чем непосредственно в нем;</li>
							<li>а управление разделяемыми объектами. Так как объекты разделяются, клиен-
							ты не должны инстанцировать их напрямую. Фабрика FlyweightFactory
							позволяет клиентам найти подходящего приспособленца. В объектах этого
							класса часто есть хранилище, организованное в виде ассоциативного масси-
							ва, с помощью которого можно быстро находить приспособленца, нужного
							клиенту. Так, в примере редактора документов фабрика приспособленцев
							может содержать внутри себя таблицу, индексированную кодом символа,
							и возвращать нужного приспособленца по его коду. А если требуемый при-
							способленец отсутствует, он тут же создается.
							Разделяемость подразумевает также, что имеется некоторая форма подсче-
							та ссылок или сбора мусора для освобождения занимаемой приспособлен-
							цем памяти, когда необходимость в нем отпадает. Однако ни то, ни другое
							необязательно, если число приспособленцев фиксировано и невелико (на-
							пример, если речь идет о представлении набора символов кода ASCII).
							В таком случае имеет смысл хранить приспособленцев постоянно.</li>
						</ul>
					<h4>Пример кода</h4>
					<p>Возвращаясь к примеру с редактором документов, определим базовый класс
					Glyph для графических объектов-приспособленцев. Логически глифы - это со-
					ставные объекты, которые обладают графическими атрибутами и умеют изображать
					себя (см. описание паттерна компоновщик). Сейчас мы ограничимся только шриф-
					том, но тот же подход применим и к любым другим графическим атрибутам:</p>
					<pre>
						class Glyph {
						public:
						virtual ~Glyph();
						virtual void Draw(Window*, GlyphContext&);
						virtual void SetFont(Font*, GlyphContextk);
						virtual Font* GetFont(GlyphContextk);
						virtual void First(GlyphContext&);
						virtual void Next(GlyphContext&);
						virtual bool IsDone(GlyphContext&);
						virtual Glyph* Current(GlyphContextk);
						virtual void Insert(Glyph*, GlyphContextu);
						virtual void Remove(GlyphContext&};
						protected:
						Glyph();
						};
						В подклассе Character хранится просто код символа:
						class Character : public Glyph {
						public:
						Character(char);
						virtual void Draw(Window*, GlyphContext&);
						private:
						char _charcode;
						};
					</pre>
					<p>Чтобы не выделять память для шрифта каждого глифа, будем хранить этот
					атрибут во внешнем объекте класса GlyphContext. Данный объект поддерживает
					соответствие между глифом и его шрифтом (а также любыми другими графически-
					ми атрибутами) в различных контекстах. Любой операции, у которой должна быть
					информация о шрифте глифа в данном контексте, в качестве параметра будет пере-
					даваться экземпляр GlyphContext. У него операция и может запросить нужные
					сведения. Контекст определяется положением глифа в структуре. Поэтому опера-
					циями обхода и манипулирования потомками обновляется GlyphContext:</p>
					<pre>
						class GlyphContext {
						public:
						GlyphContext();
						virtual -GlyphContext();
						virtual void Next(int step = 1);
						virtual void Insert(int quantity = 1);
						virtual Font* GetFont();
						virtual void SetFont(Font*, int span = 1);
						private:
						int _index;
						BTree* _fonts;
						};
					</pre>
					<p>Объекту GlyphContext должно быть известно о текущем положении в струк-
					туре глифов во время ее обхода. Операция GlyphContext: .-Next увеличивает
					переменную _index по мере обхода структуры. Подклассы класса Glyph, имею-
					щие потомков (например, Row и Column), должны реализовывать операцию Next
					так, чтобы она вызывала GlyphContext: :Next в каждой точке обхода.</p>
					<p>Операция GlyphContext: :GetFont использует переменную _index в ка-
					честве ключа для структуры ВТгее, в которой хранится отображение между гли-
					фами и шрифтами. Каждый узел дерева помечен длиной строки, для которой он
					предоставляет информацию о шрифте. Листья дерева указывают на шрифт, а внут-
					ренние узлы разбивают строку на подстроки - по одной для каждого потомка.
					Рассмотрим фрагмент текста, представляющий собой композицию глифов.</p>
					<img src="img/img-pattern/img1608.jpg" alt="" />
					<p>Структура ВТгее, в которой хранится информация о шрифтах, может выгля-
					деть так:</p>
					<img src="img/img-pattern/img1612.jpg" alt="" />
					<p>Внутренние узлы определяют диапазоны индексов глифов. Дерево обновля-
					ется в ответ на изменение шрифта, а также при каждом добавлении и удалении
					глифов из структуры. Например, если предположить, что текущей точке обхода
					соответствует индекс 102, то следующий код установит шрифт каждого символа
					в слове «expect» таким же, как у близлежащего текста (то есть times 12 - экземп-
					ляр класса Font для шрифта Times Roman размером 12 пунктов):</p>
					<pre>
						GlyphContext gc;
						Font* timesl2 = new Font("Times-Roman-12");
						Font* timesltalic!2 = new Font("Times-Italic-12");
						// ...
						gc.SetFont(times12, 6);
					</pre>
					<p>Новая структура ВТгее выглядит так (изменения выделены более
					цветом):</p>
					<img src="img/img-pattern/img1621.jpg" alt="" />
					<p>Добавим перед «expect» слово «don't » (включая пробел после него), написан-
					ное шрифтом Times Italic размером 12 пунктов. В предположении, что текущей
					позиции все еще соответствует индекс 102, следующий код проинформирует
					объект gc об этом:</p>
					<pre>
						gc.Insert(6) ;
						gc.SetFont(timesltalicl2, 6);
					</pre>
					<p>Теперь структура ВТгее выглядит так:</p>
					<img src="img/img-pattern/img1619.jpg" alt="" />
					<p>При запрашивании шрифта текущего глифа объект GlyphContext спускает-
					ся вниз по дереву, суммируя индексы, пока не будет найден шрифт для текущего
					индекса. Поскольку шрифт меняется нечасто, размер дерева мал по сравнению
					с размером структуры глифов. Это позволяет уменьшить расходы на хранение без
					заметного увеличения времени поиска.</p>
					<p>И наконец, нам нужна еще фабрика FlyweightFactory, которая создает гли-
					фы и обеспечивает их корректное разделение. Класс GlyphFactory создает
					объекты Character и глифы других видов. Разделению подлежат только объек-
					ты Character. Составных глифов гораздо больше, и их существенное состояние
					(то есть множество потомков) в любом случае является внутренним:</p>
					<pre>
						const int NCHARCODES = 128;
						class GlyphFactory {
						public:
						GlyphFactory ( ) ;
						virtual -GlyphFactory ();
						virtual Character* CreateCharacter (char) ;
						virtual Row* CreateRowO ;
						virtual Column* CreateColumnO ;
						// ...
						private:
						Character* _character [NCHARCODES] ;
						};
					</pre>
					<p>Массив _character содержит указатели на глифы Character, индексиро-
					ванные кодом символа. Конструктор инициализирует этот массив нулями:</p>
					<pre>
						GlyphFactory: : GlyphFactory () {
						for (int i = 0; i < NCHARCODES; ++i) {
						character [i] = 0;
						}
						}
					</pre>
					<p>Операция CreateCharacter ищет символ в массиве и возвращает соответ-
					ствующий глиф, если он существует. В противном случае CreateCharacter со-
					здает глиф, помещает его в массив и затем возвращает:</p>
					<pre>
						Character* GlyphFactory::CreateCharacter (char с) {
						if (!_character[с]) {
						_character[с] = new Character(с);
						}
						return _character[c];
						}
					</pre>
					<p>Остальные операции просто создают новый объект при каждом обращении,
					так как несимвольные глифы не разделяются:</p>
					<p>Время поиска в этой схеме пропорционально частоте смены шрифта. Наименьшая производитель-
					ность бывает, когда смена шрифта происходит на каждом символе, но на практике это бывает редко.</p>
					<pre>
						Row* GlyphFactory:rCreateRow () {
						return new Row;
						}
						Column* GlyphFactory::CreateColumn () {
						return new Column;
						}
					</pre>
					<p>Эти операции можно было бы опустить и позволить клиентам инстанциро-
					вать неразделяемые глифы напрямую. Но если позже мы решим сделать разделяе-
					мыми и их тоже, то придется изменять клиентский код, в котором они создаются.</p>
					<h4>Известные применения</h4>
					<p>Концепция объектов-приспособленцев впервые была описана и использована
					как техника проектирования в библиотеке Interviews 3.0 [CL90]. Ее разработчи-
					ки построили мощный редактор документов Doc, чтобы доказать практическую
					полезность подобной идеи. В Doc объекты-глифы используются для представле-
					ния любого символа документа. Редактор строит по одному экземпляру глифа для
					каждого сочетания символа и стиля (в котором определены все графические ат-
					рибуты). Таким образом, внутреннее состояние символа состоит из его кода и ин-
					формации о стиле (индекс в таблицу стилей).1 Следовательно, внешней оказывает-
					ся только позиция, -поэтому Doc работает быстро. Документы представляются
					классом Document, который выполняет функции фабрики FlyweightFactory.<p>
					<p>Измерения показали, что реализованное в Doc разделение символов-приспособ-
					ленцев весьма эффективно. В типичном случае для документа из 180 тысяч зна-
					ков необходимо создать только 480 объектов-символов.</p>
					<p>В каркасе ЕТ++ [WGM88] приспособленцы используются для поддержки не-
					зависимости от внешнего облика.2 Его стандарт определяет расположение элемен-
					тов пользовательского интерфейса (полос прокрутки, кнопок, меню и пр., в сово-
					купности именуемых виджетами) и их оформления (тени и т.д.). Виджет делегирует
					заботу о своем расположении и изображении отдельному объекту Layout. Из-
					менение этого объекта ведет к изменению внешнего облика даже во время вы-
					полнения.</p>
					<p>Для каждого класса виджета имеется соответствующий класс Layout (напри-
					мер, ScrollbarLayout, MenubarLayout и т.д.). В данном случае очевидная про-
					блема состоит в том, что удваивается число объектов пользовательского интер-
					фейса, ибо для каждого интерфейсного объекта есть дополнительный объект
					Layout. Чтобы избавиться от расходов, объекты Layout реализованы в виде при-
					способленцев. Они прекрасно подходят на эту роль, так как заняты преимуще-
					ственно определением поведения и им легко передать тот небольшой объем внеш-
					ней информации о состоянии, который необходим для изображения объекта.</p>					

			</div>

			<div class="container">
				<ul style="display: inline;">
					<li style="display: inline;"><a href="index.html">Главная</a></li>
					<li style="display: inline;"><a> &raquo; </a></li>
					<li style="display: inline;"><a href="flyweight.html"><b>Паттерн Flyweight</b></a></li>
				</ul>				
			</div>

		</section>
	</main>
	<footer>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>

	
</body>
</html>