<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<title></title>
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
	<link href='https://fonts.googleapis.com/css?family=Lobster|Open+Sans:400,300,700,300italic,600&subset=latin,cyrillic' rel='stylesheet' type='text/css'>
</head>
<body>
	<header>
		<div class="container">
			<div class="author-name">Э. Гамма</div>
			<div class="author-name">Р. Хелм</div>
			<div class="author-name">Р. Джонсон</div>
			<div class="author-name">Дж. Влиссидес</div>
		</div>
	</header>
	<main>
		<section class="promo-section">
		<div class="overlay"></div>
			<div class="container">
				<div class="titles-wrapper">
						<h1>Приемы объектно-ориентированного проектирования </h1>
						<h3>Паттерны проектирования</h3>
					<div>
						<h5>Глава 4. Структурные паттерны : Паттерн Facade</h5>
					</div>
				</div>
			</div>
		</section>
		
		<section class="patterns-section">
			<div class="container">
				<ul style="display: inline;">
					<li style="display: inline;"><a href="index.html">Главная</a></li>
					<li style="display: inline;"><a> &raquo; </a></li>
					<li style="display: inline;"><a href="decorator.html"><b>Паттерн Facade</b></a></li>
				</ul>
			</div>

			<div class="container">
				<h2 class="title">Паттерн Facade</h2>
				<h3>Название и классификация паттерна</h3>
				<p>Фасад - паттерн, структурирующий объекты.</p>
				<h4><i>Назначение</i></h4>
				<p>Предоставляет унифицированный интерфейс вместо набора интерфейсов не-
				которой подсистемы. Фасад определяет интерфейс более высокого уровня, кото-
				рый упрощает использование подсистемы.</p>
				<h4>Мотивация</h4>
				<p>Разбиение на подсистемы облегчает проектирование сложной системы в целом.
				Общая цель всякого проектирования - свести к минимуму зависимость подсистем
				друг от друга и обмен информацией между ними. Один из способов решения этой
				задачи - введение объекта фасад, предоставляющий единый упрощенный интер-
				фейс к более сложным системным средствам.</p>
				<img src="img/img-pattern/img1508.jpg" alt="" />
				<p>Рассмотрим, например, среду программирования, которая дает приложени-
				ям доступ к подсистеме компиляции. В этой подсистеме имеются такие классы,
				как Scanner (лексический анализатор), Parser (синтаксический анализатор),
				ProgramNode (узел программы), BytecodeStream (поток байтовых кодов)
				и ProgramNodeBuilder (строитель узла программы). Все вместе они состав-
				ляют компилятор. Некоторым специализированным приложениям, возможно,
				понадобится прямой доступ к этим классам. Но для большинства клиентов ком-
				пилятора такие детали, как синтаксический разбор и генерация кода, обычно не
				нужны; им просто требуется откомпилировать некоторую программу. Для таких
				клиентов применение мощного, но низкоуровневого интерфейса подсистемы ком-
				пиляции только усложняет задачу.</p>
				<img src="img/img-pattern/img1517.jpg" alt="" />
				<p>Чтобы предоставить интерфейс более высокого уровня, изолирующий клиен-
				та от этих классов, в подсистему компиляции включен также класс Compiler
				(компилятор). Он определяет унифицированный интерфейс ко всем возможнос-
				тям компилятора. Класс Compiler выступает в роли фасада: предлагает простой
				интерфейс к более сложной подсистеме. Он «склеивает» классы, реализующие
				функциональность компилятора, но не скрывает их полностью. Благодаря фаса-
				ду компилятора работа большинства программистов облегчается. При этом те,
				кому нужен доступ к средствам низкого уровня, не лишаются его.</p>
				<h4>Применимость</h4>
				<p>Используйте паттерн фасад, когда:</p>
					<ul>
						<li>а хотите предоставить простой интерфейс к сложной подсистеме. Часто подсис-
						темы усложняются по мере развития. Применение большинства паттернов
						приводит к появлению меньших классов, но в большем количестве. Такую
						подсистему проще повторно использовать и настраивать под конкретные
						нужды, но вместе с тем применять подсистему без настройки становится
						труднее. Фасад предлагает некоторый вид системы по умолчанию, устраи-
						вающий большинство клиентов. И лишь те объекты, которым нужны более
						широкие возможности настройки, могут обратиться напрямую к тому, что
						находится за фасадом;</li>
						<li>а между клиентами и классами реализации абстракции существует много за-
						висимостей. Фасад позволит отделить подсистему как от клиентов, так
						и от других подсистем, что, в свою очередь, способствует повышению степе-
						ни независимости и переносимости;</li>
						<li>а вы хотите разложить подсистему на отдельные слои. Используйте фасад для
						определения точки входа на каждый уровень подсистемы. Если подсисте-
						мы зависят друг от друга, то зависимость можно упростить, разрешив под-
						системам обмениваться информацией только через фасады.</li>
					</ul>
				<h4>Структура</h4>
				<img src="img/img-pattern/img1524.jpg" alt="" />
				<h4>Участники</h4>
				<ul>
					<li><p>a Facade (Compiler) - фасад:</p>
						<ul>
							<li>- «знает», каким классам подсистемы адресовать запрос;</li>
							<li>- делегирует запросы клиентов подходящим объектам внутри подсистемы;</li>				
						</ul>
					</li>
					<li><p>а Классы подсистемы (Scanner, Parser, ProgramNode и т.д.):</p>
						<ul>
							<li>- реализуют функциональность подсистемы;</li>
							<li>- выполняют работу, порученную объектом Facade;</li>
							<li>- ничего не «знают» о существовании фасада, то есть не хранят ссылок на
							него.</li>
						</ul>
				</ul>
				<h4>Отношения</h4>
				<p>Клиенты общаются с подсистемой, посылая запросы фасаду. Он переадресу-
				ет их подходящим объектам внутри подсистемы. Хотя основную работу выполня-
				ют именно объекты подсистемы, фасаду, возможно, придется преобразовать свой
				интерфейс в интерфейсы подсистемы.</p>
				<p>Клиенты, пользующиеся фасадом, не имеют прямого доступа к объектам под-
				системы.</p>
				<h4>Результаты</h4>
				<p>У паттерна фасад есть следующие преимущества:</p>
					<ul>
						<li>а изолирует клиентов от компонентов подсистемы, уменьшая тем самым чис-
						ло объектов, с которыми клиентам приходится иметь дело, и упрощая рабо-
						ту с подсистемой;</li>
						<li>а позволяет ослабить связанность между подсистемой и ее клиентами. Зачас-
						тую компоненты подсистемы сильно связаны. Слабая связанность позволя-
						ет видоизменять компоненты, не затрагивая при этом клиентов. Фасадь:
						помогают разложить систему на слои и структурировать зависимости между
						объектами, а также избежать сложных и циклических зависимостей. Это мо-
						жет оказаться важным, если клиент и подсистема реализуются независимо
						Уменьшение числа зависимостей на стадии компиляции чрезвычайно важ-
						но в больших системах. Хочется, конечно, чтобы время, уходящее на пере-
						компиляцию после изменения классов подсистемы, было минимальным
						Сокращение числа зависимостей за счет фасадов может уменьшить количе-
						ство нуждающихся в повторной компиляции файлов после небольшой моди-
						фикации какой-нибудь важной подсистемы. Фасад может также упростить
						процесс переноса системы на другие платформы, поскольку уменьшается ве-
						роятность того, что в результате изменения одной подсистемы понадобится
						изменять и все остальные;</li>
						<li>а фасад не препятствует приложениям напрямую обращаться к классам под-
						системы, если это необходимо. Таким образом, у вас есть выбор между прос-
						тотой и общностью.</li>
					</ul>
				<h4>Реализация</h4>
				<p>При реализации фасада следует обратить внимание на следующие вопросы:<p>
					<ul>
					<li><i>а уменьшение степени связанности клиента с подсистемой.</i> Степень связан-
					ности можно значительно уменьшить, если сделать класс Facade абстракт-
					ным. Его конкретные подклассы будут соответствовать различным реали-
					зациям подсистемы. Тогда клиенты смогут взаимодействовать с подсистемой
					через интерфейс абстрактного класса Facade. Это изолирует клиентов от ин-
					формации о том, какая реализация подсистемы используется.
					Вместо порождения подклассов можно сконфигурировать объект Facade
					различными объектами подсистем. Для настройки фасада достаточно заме-
					нить один или несколько таких объектов;</li>
					<li><i>а открытые и закрытые классы подсистем.</i> Подсистема похожа на класс в том
					отношении, что у обоих есть интерфейсы и оба что-то инкапсулируют
					Класс инкапсулирует состояние и операции, а подсистема - классы. И если
					полезно различать открытый и закрытый интерфейсы класса, то не менее ра-
					зумно говорить об открытом и закрытом интерфейсах подсистемы.
					Открытый интерфейс подсистемы состоит из классов, к которым имеют до-
					ступ все клиенты; закрытый интерфейс доступен только для расширения
					подсистемы. Класс Facade, конечно же, является частью открытого интер-
					фейса, но это не единственная часть. Другие классы подсистемы также мо-
					гут быть открытыми. Например, в системе компиляции классы Parser
					и Scanner - часть открытого интерфейса.
					Делать классы подсистемы закрытыми иногда полезно, но это поддерживает-
					ся немногими объектно-ориентированными языками. И в C++, и в Smalltalk
					для классов традиционно использовалось глобальное пространство имен.
					Однако комитет по стандартизации C++ добавил к языку пространства имен
					[Str94], и это позволило разрешать доступ только к открытым классам под-
					системы.</li>
					</ul>
				<h4>Пример кода</h4>
				<p>Рассмотрим более подробно, как возвести фасад вокруг подсистемы компиляции.
				В подсистеме компиляции определен класс BytecodeStream, который реа-
				лизует поток объектов Bytecode. Объект Bytecode инкапсулирует байтовый
				код, с помощью которого описываются машинные команды. В этой же подсисте-
				ме определен еще класс Token для объектов, инкапсулирующих лексемы языка
				программирования.</p>
				<p>Класс Scanner принимает на входе поток символов и генерирует поток лек-
				сем, по одной каждый раз:</p>
				<pre>
					class Scanner {
					public:
					Scanner(istream&);
					virtual -Scanner();
					virtual Token& Scan();
					private:
					istream& _inputStream;
					};
				</pre>
				<p>Класс Parser использует класс ProgramNodeBuilder для построения де-
				рева разбора из лексем, возвращенных классом Scanner:</p>
				<pre>
					class Parser {
					public:
					Parser();
					virtual -Parser();
					virtual void Parse(Scanners, ProgramNodeBuilder&);
					, };
				</pre>
				<p>Parser вызывает ProgramNodeBuilder для инкрементного построения де-
				рева. Взаимодействие этих классов описывается паттерном строитель:</p>
				<pre>
					class ProgramNodeBuilder {
					public:
					ProgramNodeBuilder();
					virtual ProgramNode* NewVariable(
					const char* variableName
					) const;
					virtual ProgramNode* NewAssignment(
					ProgramNode* variable, ProgramNode* expression
					) const;
					virtual ProgramNode* NewReturnStatement(
					ProgramNode* value
					) const;
					virtual ProgramNode* NewCondition(
					ProgramNode* condition,
					ProgramNode* truePart, ProgramNode* falsePart
					) const;
					// ...
					ProgramNode* GetRootNode();
					private:
					ProgramNode* _node;
					};
				</pre>
				<p>Дерево разбора состоит из экземпляров подклассов класса ProgramNode, таких
				как StatementNode, ExpressionNode и т.д. Иерархия классов ProgramNode — это
				пример паттерна компоновщик. Класс ProgramNode определяет интерфейс для
				манипулирования узлом программы и его потомками, если таковые имеются:</p>
				<pre>
					class ProgramNode {
					public:
					// манипулирование узлом программы
					virtual void GetSourcePosition(int& line, int& index);
					// ...
					// манипулирование потомками
					virtual void Add(ProgramNode*);
					virtual void Remove(ProgramNode*);
					// .. .
					virtual void Traverse(CodeGeneratork);
					protected:
					ProgramNode();
					};
				</pre>
				<p>Операция Traverse (обход) принимает объект CodeGenerator (кодогенера-
				тор) в качестве параметра. Подклассы ProgramNode используют этот объект для ге-
				нерации машинного кода в форме объектов Bytecode, которые помещаются в по-
				ток BytecodeStream. Класс CodeGenerator описывается паттерном посетитель:</p>
				<pre>
					class CodeGenerator {
					public:
					virtual void Visit(StatementNode*);
					virtual void Visit(ExpressionNode*);
					// ...
					protected:
					CodeGenerator(BytecodeStreamk);
					protected:
					BytecodeStreamk _output;
					};
				</pre>
				<p>У CodeGenerator есть подклассы, например StackMachineCodeGenerator
				и RISCCodeGenerator, генерирующие машинный код для различных аппаратных
				архитектур.</p>
				<p>Каждый подкласс ProgramNode реализует операцию Traverse и обращает-
				ся к ней для обхода своих потомков. Каждый потомок рекурсивно делает то же са-
				мое для своих потомков. Например, в подклассе ExpressionNode (узел выраже-
				ния) операция Traverse определена так:</p>
				<pre>
					void ExpressionNode::Traverse (CodeGenerator& eg) {
					eg.Visit(this);
					ListIterator<ProgramNode*> i(_children);
					for (i. First ( ) ; ! i . IsDone () ; i.NextO) {
					i.Currentltem()->Traverse(eg);
					}
					}
				</pre>
				<p>Классы, о которых мы говорили до сих пор, составляют подсистему компиля-
				ции. А теперь введем класс Compiler, который будет служить фасадом, позволяю-
				щим собрать все эти фрагменты воедино. Класс Compiler предоставляет простой
				интерфейс для компилирования исходного текста и генерации кода для конкрет-
				ной машины:</p>
				<pre>
					class Compiler {
					public:
					Compiler();
					virtual void Compile(istream&, BytecodeStream&);
					};
					void Compiler::Compile (
					istream& input, BytecodeStreamk output
					) {
					Scanner scanner(input);
					ProgramNodeBuilder builder;
					Parser parser;
					parser.Parse(scanner, builder);
					RISCCodeGenerator generator(output);
					ProgramNode* parseTree = builder.GetRootNode();
					parseTree->Traverse(generator);
					}
				</pre>
				<p>В этой реализации жестко «зашит» тип кодогенератора, поэтому программисту
				не нужно явно задавать целевую архитектуру. Это может быть вполне разумно, когда
				есть всего одна такая архитектура. Если же это не так, можно было бы изменить кон-
				структор класса Compiler, чтобы он принимал объект CodeGenerator в качестве
				параметра. Тогда программист указывал бы, каким генератором пользоваться при
				инстанцировании объекта Compiler. Фасад компилятора можно параметризовать
				и другими участниками, скажем, объектами Scanner и ProgramNodeBuilder, что
				повышает гибкость, но в то же время сводит на нет основную цель фасада - предо-
				ставление упрощенного интерфейса для наиболее распространенного случая.</p>
				<h4>Известные применения</h4>
				<p>Пример компилятора в разделе «Пример кода» навеян идеями из системы
				компиляции языка ObjectWorks\Smalltalk [РагЭО].</p>
				<p>В каркасе ЕТ++ [WGM88] приложение может иметь встроенные средства
				инспектирования объектов во время выполнения. Они реализуются в отдельной
				подсистеме, включающей класс фасада с именем ProgrammingEnvironment.
				Этот фасад определяет такие операции, как InspectObject и InspectClass
				для доступа к инспекторам.</p>
				<p>Приложение, написанное в среде ЕТ++, может также запретить поддержку
				инспектирования. В таком случае класс ProgrammingEnvironment реализует
				соответствующие запросы как пустые операции, не делающие ничего. Только под-
				класс ETProgrammingEnvironment реализует эти операции так, что они отобра-
				жают окна соответствующих инспекторов. Приложению неизвестно, доступно
				инспектирование или нет. Здесь мы встречаем пример абстрактной связанности
				между приложением и подсистемой инспектирования.</p>
				<p>В операционной системе Choices [CIRM93] фасады используются для состав-
				ления одного каркаса из нескольких. Ключевыми абстракциями в системе Choices
				являются процессы, память и адресные пространства. Для каждой из них есть соот-
				ветствующая подсистема, реализованная в виде каркаса. Это обеспечивает поддерж-
				ку переноса Choices на разные аппаратные платформы. У двух таких подсистем есть
				«представители», то есть фасады. Они называются FileSystemlnterface (па-
				мять) и Domain (адресные пространства).</p>
				<img src="img/img-pattern/img1551.jpg" alt="" />
				<p>Например, для каркаса виртуальной памяти фасадом служит Domain. Класс
				Domain представляет адресное пространство. Он обеспечивает отображение между
				виртуальными адресами и смещениями объектов в памяти, файле или на устрой-
				стве длительного хранения. Базовые операции класса Domain поддерживают до-
				бавление объекта в память по указанному адресу, удаление объекта из памяти
				и обработку ошибок отсутствия страниц.</p>
				<p>Как видно из вышеприведенной диаграммы, внутри подсистемы виртуальной
				памяти используются следующие компоненты:</p>
					<ul>
						<li>a MemoryObject представляет объекты данных;</li>
						<li>a MemoryObj ectCache кэширует данные из объектов MemoryObj ects в фи-
						зической памяти. MemoryObj ectCache - это не что иное, как объект Стра-
						тегия, в котором локализована политика кэширования;</li>
						<li>a AddressTranslat ion инкапсулирует особенности оборудования трансля-
						ции адресов.</li>
					</ul>
				<p>Операция RepairFault вызывается при возникновении ошибки из-за отсут-
				ствия страницы. Domain находит объект в памяти по адресу, где произошла ошиб-
				ка и делегирует операцию RepairFault кэшу, ассоциированному с этим объек-
				том. Поведение объектов Domain можно настроить, заменив их компоненты.</p>
				<h4>Родственные паттерны</h4>
				<p>Паттерн абстрактная фабрика допустимо использовать вместе с фасадом,
				чтобы предоставить интерфейс для создания объектов подсистем способом, не за-
				висимым от этих подсистем. Абстрактная фабрика может выступать и как аль-
				тернатива фасаду, чтобы скрыть платформенно-зависимые классы.</p>
				<p>Паттерн посредник аналогичен фасаду в том смысле, что абстрагирует функ-
				циональность существующих классов. Однако назначение посредника - абстра-
				гировать произвольное взаимодействие между «сотрудничающими» объектами.
				Часто он централизует функциональность, не присущую ни одному из них. Кол-
				леги посредника обмениваются информацией именно с ним, а не напрямую меж-
				ду собой. Напротив, фасад просто абстрагирует интерфейс объектов подсистемы,
				чтобы ими было проще пользоваться. Он не определяет новой функциональности,
				и классам подсистемы ничего неизвестно о его существовании.</p>
				<p>Обычно требуется только один фасад. Поэтому объекты фасадов часто бы-
				вают одиночками.</p>

			</div>

			<div class="container">
				<ul style="display: inline;">
					<li style="display: inline;"><a href="index.html">Главная</a></li>
					<li style="display: inline;"><a> &raquo; </a></li>
					<li style="display: inline;"><a href="decorator.html"><b>Паттерн Facader</b></a></li>
				</ul>				
			</div>

		</section>
	</main>
	<footer>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>

	
</body>
</html>